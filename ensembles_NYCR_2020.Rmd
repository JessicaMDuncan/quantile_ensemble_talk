---
title: "Ensemble forecasts with fable"
author: Rob J Hyndman
date: 14 August 2020
fontsize: 14pt
classoption: aspectratio=169
toc: false
output:
  binb::monash:
    fig_height: 4.33
    fig_width: 7
    colortheme: monashwhite
    keep_tex: yes
    includes:
      in_header: preamble.tex
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(
  echo = FALSE,
  message=FALSE,
  warning=FALSE,
  cache=TRUE,
  dev.args=list(bg=grey(0.9), pointsize=11)
)
library(fpp3)
library(distributional)
library(gganimate)
set.seed(2020-08-10)

if (file.exists("cafe.rds")) {
  cafe <- readRDS("cafe.rds")
} else {
  cafe <- readabs::read_abs(series_id = "A3349870V") %>%
    select(date, value) %>%
    mutate(date = yearmonth(date)) %>%
    as_tsibble(index = date) %>%
    filter(
      date >= yearmonth("2006 Jan"),
      date <= yearmonth("2019 Dec")
    ) %>%
    rename(turnover = value)
  saveRDS(cafe, "cafe.rds")
}
```

## Forecasting using possible futures

```{r samples, echo=FALSE}
# Training data
train <- cafe %>%
  filter(year(date) <= 2017)
# Fit ETS model
fit <- train %>%
  model(ETS = ETS(turnover)) 
# Forecasts
fc <- fit %>%
  forecast(h = "2 years")
# Future sample paths
future <- fit %>%
  generate(times = 1000, h = "2 years") %>%
  as_tibble() %>%
  mutate(modrep = paste0(.model, .rep)) 
# Colours for sample paths. Need to permute to avoid all similar colours on top in graph
colours <- tibble(modrep = unique(future$modrep)) %>%
  mutate(col = sample(rainbow(1000)))
future <- future %>% left_join(colours, by = "modrep")
```

```{r plots, echo=FALSE}
p1 <- train %>%
  autoplot(turnover) +
  labs(
    x = "Month",
    y = "Turnover (A$million)",
    title = "Australian monthly café turnover: ETS futures"
  ) +
  guides(colour = FALSE, level=FALSE)
p1 + 
  geom_line(
    data = filter(future, as.numeric(.rep) <= 5),
    aes(y = .sim, col=col, group = c(modrep)),
  ) 
```

## Forecasting using possible futures

```{r samples2, echo=FALSE, dependson='samples'}
p1$data <- train %>% filter(year(date) >= 2015)
p1 <- p1 + 
  ylim(min(p1$data$turnover), max(future$.sim)) 
p1 + 
  geom_line(
    data = filter(future, as.numeric(.rep) <= 5),
    aes(y = .sim, col=col, group = c(modrep)),
  )
```

## Forecasting using possible futures

```{r samples2a, echo=FALSE, dependson='samples'}
p1 + 
  geom_line(
    data = filter(future),
    aes(y = .sim, col=col, group = c(modrep)),
  )
```


## Forecasting using possible futures

```{r samples3, echo=FALSE, dependson='samples2'}
p1 <- p1 + 
  geom_line(
    data = future,
    aes(y = .sim, group = modrep),
    color = 'gray', alpha=0.2
  ) 
p1
```

## Forecasting using possible futures

```{r point, echo=FALSE, dependson='samples3'}
p1 + 
  autolayer(fc, level=NULL, lwd=1) 
```

\begin{textblock}{4.2}(11.5,1.5)\fontsize{11}{13}\sf
\begin{block}{}
\textbf{Point forecasts:} means of the sample paths.
\end{block}
\end{textblock}

## Forecasting using possible futures

```{r interval, echo=FALSE, dependson='samples3'}
p1 +
  autolayer(fc, level=80, lwd=1) 
```

\begin{textblock}{4.2}(11.5,1.5)\fontsize{11}{13}\sf
\begin{block}{}
\textbf{Point forecasts:} means of the sample paths.
\end{block}
\begin{block}{}
\textbf{Prediction intervals:} middle 80\% of the sample paths at each forecast horizon.
\end{block}
\end{textblock}

## Forecasting using possible futures

```{r quantile, echo=FALSE, dependson='samples3'}
p1 + 
  autolayer(fc, level=80, lwd=1)
```

\begin{textblock}{4.2}(11.5,1.5)\fontsize{11}{13}\sf
\begin{block}{}
\textbf{Point forecasts:} means of the sample paths.
\end{block}
\begin{block}{}
\textbf{Prediction intervals:} middle 80\% of the sample paths at each forecast horizon.
\end{block}
\begin{block}{}
\textbf{Quantile forecasts:} Quantiles of the sample paths at each forecast horizon.
\end{block}
\end{textblock}


## Quantile forecasts

```{r quantiles, dependson='samples3'}
qf <- fit %>%
  generate(times = 1000, h = "2 years") %>%
  as_tibble() %>%
  group_by(date) %>%
  summarise(
    qs = quantile(.sim, seq(from = 0.1, to = 0.9, by = 0.1)), prob = seq(from = 0.1, to = 0.9, by = 0.1)
  )
p1 <- p1  +
  geom_line(
    data=qf, 
    mapping=aes(x = date, y=qs, group=prob), 
    colour="blue"
  )
p1
```

\begin{textblock}{4.2}(11.5,1.5)\fontsize{11}{13}\sf
\begin{block}{}
\textbf{Blue:} Deciles for the ETS forecasts for the Australian monthly café turnover.
\end{block}
\end{textblock}

## Quantile forecasts

```{r quantiles3, dependson='quantiles'}
p1 + 
  geom_line(aes(y = turnover), data = cafe %>% filter(year(date) >= 2018))
```

\begin{textblock}{4.2}(11.5,1.5)\fontsize{11}{13}\sf
\begin{block}{}
\textbf{Blue:} Deciles for the ETS forecasts for the Australian monthly café turnover. \textbf{Black:} Observed values.
\end{block}
\end{textblock}

## Evaluating quantile forecasts

\begin{textblock}{9.5}(0.2,1.2)
\begin{alertblock}{}\vspace*{-0.8cm}
\begin{align*}
f_{p,t} &= \text{quantile forecast with prob. $p$ at time $t$.}\\
y_{t} &= \text{observation at time $t$}
\end{align*}
\end{alertblock}\vspace*{-0.3cm}
\uncover<2->{\begin{block}{Quantile score}\vspace*{-0.6cm}
$$
  Q_{p,t} = \begin{cases}
  2(1 - p) \big|y_t - f_{p,t}\big|, & \text{if $y_{t} < f_{p,t}$}\\
  2p \big|y_{t} - f_{p,t}\big|, & \text{if $y_{t} \ge f_{p,t}$} \end{cases}
$$
\end{block}}
\end{textblock}
\begin{textblock}{15}(0.2,5.6)
\uncover<4->{
\begin{itemize}\itemsep=0cm\parskip=0cm
\item Low $Q_p$ is good
\item Multiplier of 2 often omitted, but useful for interpretation
\item $Q_p$ like absolute error (weighted to account for likely exceedance)
\item Average $Q_p$ = CRPS (Continuous Rank Probability Score)
\end{itemize}}
\end{textblock}
\begin{textblock}{6}(10,2)
\only<3->{\animategraphics[loop]{10}{ensembles_NYCR_2020_files/figure-beamer/pinball-}{1}{100}}
\end{textblock}

```{r pinball, eval=FALSE, echo=FALSE, fig.show='animate', interval=1/10, message=FALSE, fig.height=3, fig.width=5}
# Turn eval=TRUE to recompute these graphs. They are loaded in the above animategraphics call.
prob <- seq(0.05,0.95,by=0.05)
df <- expand.grid(
    error = c(-10,0,10),
    p = c(prob,rev(head(prob,-1)[-1]))
  ) %>%
  mutate(
    state = rep(seq(length(p)/3),rep(3,length(p)/3)),
    qpt = 2*p*error*(error>0) - 2*(1-p)*error*(error<0)
  ) 
labels <- df %>%
  select(p,state) %>%
  distinct() %>%
  mutate(label = paste0("p = ",sprintf("%.2f",p)))
df %>%ggplot(aes(x=error, y=qpt)) +
  geom_line(aes(group=state), colour='red') +
  labs(
    x= latex2exp::TeX("Error: $y_t - f_{p,t}$"),
    y = latex2exp::TeX("Q_{p,t}")
  ) +
  geom_label(data = labels, aes(x=0, y=17, label=label)) +
  transition_states(state)
```
  
## Evaluating quantile forecasts
\fontsize{9}{10}\sf

```{r crps1, echo=TRUE}
cafe %>% 
  filter(year(date) <= 2017)
```

\vspace*{10cm}

## Evaluating quantile forecasts
\fontsize{9}{10}\sf

```{r crps2, echo=TRUE}
cafe %>% 
  filter(year(date) <= 2017) %>%
  model(
    ETS = ETS(turnover),
    ARIMA = ARIMA(turnover ~ pdq(d=1) + PDQ(D=1))
  )
```

\vspace*{10cm}

## Evaluating quantile forecasts
\fontsize{9}{10}\sf

```{r crps3, echo=TRUE}
cafe %>% 
  filter(year(date) <= 2017) %>%
  model(
    ETS = ETS(turnover),
    ARIMA = ARIMA(turnover ~ pdq(d=1) + PDQ(D=1))
  ) %>%
  forecast(h = "2 years")
```

\vspace*{10cm}

## Evaluating quantile forecasts
\fontsize{9}{10}\sf

```{r crps4, echo=TRUE}
cafe %>% 
  filter(year(date) <= 2017) %>%
  model(
    ETS = ETS(turnover),
    ARIMA = ARIMA(turnover ~ pdq(d=1) + PDQ(D=1))
  ) %>%
  forecast(h = "2 years") %>%
  accuracy(cafe, measures = list(CRPS = CRPS))
```

\vspace*{10cm}

## Ensemble forecasting
\fontsize{11}{12}\sf

**Ensemble forecasting** involves combining the forecast distributions from multiple models. 

  * “All models are wrong, but some are useful” (George Box, 1976)
  * Allows diverse models to be included, while reducing impact of any specific model. 
  * Allows uncertainty of model selection to be incorporated.

```{r ensemble_samples, echo=FALSE, fig.height=2.6}
fit <- cafe %>% 
  filter(year(date) <= 2017) %>%
  model(
    ETS = ETS(turnover),
    ARIMA = ARIMA(turnover ~ pdq(d=1) + PDQ(D=1))
  )
future <- fit %>% 
  generate(times = 10, h = "2 years")
cafe %>%
  filter(year(date) >= 2014, year(date) <= 2017) %>%
  autoplot(turnover) +
  geom_line(data = future %>% mutate(modrep = paste0(.model, .rep)), aes(y = .sim, col = .model, group = c(modrep))) +
  labs(x = "Month", y = "Turnover (A$million)") +
  guides(colour = guide_legend("Model"))
```  

## Ensemble forecasting
\fontsize{9}{10}\sf

```{r ensemble1, echo=TRUE}
cafe %>% filter(year(date) <= 2017) %>%
  model(
    ETS = ETS(turnover),
    ARIMA = ARIMA(turnover ~ pdq(d=1) + PDQ(D=1))
  ) %>%
  forecast(h = "2 years") 
```

\vspace*{10cm}

## Ensemble forecasting
\fontsize{9}{10}\sf

```{r ensemble1a, echo=TRUE}
cafe %>% filter(year(date) <= 2017) %>%
  model(
    ETS = ETS(turnover),
    ARIMA = ARIMA(turnover ~ pdq(d=1) + PDQ(D=1))
  ) %>%
  forecast(h = "2 years") -> fc
```

```{r ensemble1b, echo=FALSE}
cafe %>% filter(year(date) <= 2017) %>%
  model(
    ETS = ETS(turnover),
    ARIMA = ARIMA(turnover ~ pdq(d=1) + PDQ(D=1))
  ) %>%
  forecast(h = "2 years")
```

\vspace*{10cm}

## Ensemble forecasting
\fontsize{9}{10}\sf

```{r ensemble2, echo=TRUE, dependson='ensemble1a'}
fc %>%
  summarise(
    turnover = dist_mixture(turnover[1], turnover[2], weights=c(0.5,0.5)),
    .mean = mean(turnover)
  ) %>%
  as_fable(response = "turnover", distribution = turnover)
```

## Ensemble forecasting
\fontsize{9}{10}\sf

```{r ensemble2a, echo=TRUE, dependson='ensemble1a'}
fc %>%
  summarise(
    turnover = dist_mixture(turnover[1], turnover[2], weights=c(0.5,0.5)),
    .mean = mean(turnover)
  ) %>%
  as_fable(response = "turnover", distribution = turnover) -> ensemble
```

```{r ensemble2b, echo=FALSE, dependson='ensemble1a'}
fc %>%
  summarise(
    turnover = dist_mixture(turnover[1], turnover[2], weights=c(0.5,0.5)),
    .mean = mean(turnover)
  ) %>%
  as_fable(response = "turnover", distribution = turnover)
```


## Ensemble forecasting
\fontsize{9}{10}\sf

```{r ensemble3, echo=TRUE, dependson='ensemble2a'}
ensemble %>%
  accuracy(cafe, measures = list(CRPS = CRPS)) 
```

\fontsize{14}{16}\sf

 * In this case, the ensemble forecasts are slightly worse than the ETS forecasts.
 * 

## Combination forecasting

Combination forecasting is a related idea that is more widely used in the general forecasting community. This involves taking a weighted average of the forecasts produced from the component models. Often a simple average is used. For more than 50 years we have known that combination forecasting improves forecast accuracy [@Bates1969-dp;@Clemen1989-fz]. One of the reasons for this is that the combination decreases the variance of the forecasts [@Hibon2005-cv] by reducing the uncertainty associated with selecting a particular model.

Combinations are almost always used to produce point forecasts, not probabilistic forecasts. A weighted average of several component forecasts gives a point forecast that is identical to taking the mean of the sample paths from the corresponding weighted ensemble.

However, the idea can be used more generally to obtain quantile forecasts as well. Quantiles can not simply be averaged, so we need to take account of the correlations between the forecast errors from the component models when producing quantile forecasts. This is implemented in the `fable` package for R. For the Australian café data, this gives the following result.

```{r combinations}
fit %>%
  mutate(COMBINATION = (ETS + ARIMA) / 2) %>%
  forecast(h = "1 year") %>%
  filter(.model == "COMBINATION") %>%
  accuracy(cafe, measures = list(CRPS = CRPS))
```

Further improvement has been obtained by taking account of the similarity of the ETS and ARIMA forecasts, rather than simply combining the sample paths as with ensemble forecasting.

## Conclusions

I have described several tools for forecasting that are likely to be increasingly used in business forecasting in the future.

 * Simulated future sample paths allow us to study how the future might evolve, and allow us to answer more complicated forecasting questions than is possible with analytical methods.
 * Quantile forecasts can be produced from these simulated future sample paths and provide a way of quantifying the forecast distributions.
 * Quantile scores allow us to evaluate quantile forecasts. Averaging quantile scores gives the CRPS which allows us to evaluate the whole forecast distribution.
 * Forecast ensembles combine information from multiple models and often provide a better estimate of future uncertainty than any individual model.
 * Forecast combinations are similar to ensembles but also take account of the relationships between the component models. The best forecasts often come from combining models in this way.


## Supplements

All the forecasts and calculations produced in this chapter were obtained with the `fable` package for R. The code used is available at https://github.com/robjhyndman/quantile_ensembles.
